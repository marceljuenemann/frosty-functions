import { Signer, Promise, Hex, keccak256, verifiableRandomness } from "frosty";
import { CALLDATA, CALLING_CHAIN_NAME, CALLING_CHAIN_ID, JOB_ID } from "frosty/env";

export function main(): void {
  console.log(`Invoked from ${CALLING_CHAIN_NAME} (Chain ID: ${CALLING_CHAIN_ID})`);
  console.log(`Calldata is: ${CALLDATA}`);
  console.log(`Job ID is: ${JOB_ID}`);

  // TODO: Blurb
  const signer = Signer.forCaller();
  console.log(`Signer.forCaller() ethereum address: ${signer.ethAddress}`);
  console.log(`Signer.forCaller() public key: ${signer.publicKey}`);

  // TODO: Move to examples.
  const signer2 = Signer.forCaller(CALLDATA.bytes);
  console.log(`Signer.forCaller(CALLDATA) public key: ${signer2.publicKey}`);

  const signer3 = Signer.forFunction(CALLDATA.bytes);
  console.log(`Signer.forFunction(CALLDATA) public key: ${signer3.publicKey}`);

  let hash = keccak256(CALLDATA.bytes);
  console.log(`keccak256(CALLDATA): ${Hex.wrap(hash)}`);
  signer.signWithEcsda(hash).then(signature => {
    console.log(`Signature: ${Hex.wrap(signature)}`);
  })


  /**
   * Frosty Functions have full control over Ethereum wallets, so they can hold assets
   * and interact with smart contracts. The private keys are split accross the nodes of
   * an Internet Computer subnet and signing is done using Threshold ECDSA.
   * 
   * The following wallets can be used:
   * 1) EthWallet.forCaller(): A wallet for the caller, shared by all Frosty Functions.
   *    This can be used to manage assets on behalf of the caller (a EOA or smart contract).
   * 2) EthWallet.forFunction(): A wallet for the Frosty Function, shared by all callers.
   *    This can be used to manage assets owned by the function itself.
   * 3) EthWallet.forFunctionAndCaller(): A wallet unique to the function-caller pair.
   * 4) You can derive subaccounts of the above methods by passing a derivation paths,
   *    e.g. EthWallet.forCaller(String.UTF8.encode("subaccount/42"))
   * 
   * (Note: Only (1) is implement currently, but support for 2-4 is trivial to add.) 
   */
  /*
  const wallet = EthWallet.forCaller();
  console.log(`Caller Frosty Wallet address: ${wallet.address()}`);

  // You can use wallet.signMessage to sign arbitrary messages.
  // TODO: ABI and JSON RPC support will be added soon to actually allow interaction
  // with other chains.
  wallet.signMessage(String.UTF8.encode("Hello, World!")).then((signature) => {
    console.log(`Signature: ${hex.encode(signature)}`);
  });
  */
}


/****************************************/
/********* MORE EXAMPLES BELOW **********/ 
/****************************************/

namespace examples {

  function random(): void {
    // verifiableRandomness() returns 32 random bytes generated by chain-key cryptography,
    // see https://internetcomputer.org/docs/building-apps/network-features/randomness
    // Here we take the first 2 bytes to generate a random number between 0 and 65535.
    const random: Promise<u16> = verifiableRandomness()
      .map<u16>(bytes => Uint16Array.wrap(bytes)[0])
      .then(rand => console.log(`Random number generated: ${rand}`));
  }

  /**
   * Example demonstrating the use of Promises.
   */
  function promises(): void {
    let localValue: u16 = 42;
    verifiableRandomness()
      // Use .map to transform the Promise value. As AssemblyScript is
      // strictly typed, the return value type needs to be specified.
      .map<u16>(bytes => Uint16Array.wrap(bytes)[0])
      // AssemblyScript currently does not support closures, but you
      // can use .mapWith to pass additional context to the callback.
      // Note: Closure support will be added with https://github.com/AssemblyScript/assemblyscript/pull/2964
      .mapWith<u16, u16>(localValue, (localValue, random) => random + localValue)
      // Use .then if you don't need to transform the value anymore.
      .then(result => console.log(`Random number plus local value: ${result}`));
  }
}
