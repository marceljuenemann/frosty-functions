import { Signer, Promise, hex, keccak256, verifiableRandomness } from "frosty";
import { CALLDATA, CALLING_CHAIN_NAME, CALLING_CHAIN_ID, JOB_ID } from "frosty/env";

export function main(): void {
  console.log(`Invoked from ${CALLING_CHAIN_NAME} (Chain ID: ${CALLING_CHAIN_ID})`);
  console.log(`Calldata is: ${hex.encode(CALLDATA)}`);
  console.log(`Job ID is: ${JOB_ID}`);

  // Signer.forCaller() returns a signer unique to the caller of the Frosty Function.
  // Note the signer is shared among all Frosty Functions called by the same caller.
  // The private key is distributed among the 34 nodes of the Internet Computer's fiduciary
  // subnet, see https://learn.internetcomputer.org/hc/en-us/articles/34209497587732-Chain-Key-Signatures
  const signer = Signer.forCaller();
  console.log(`Signer.forCaller() ethereum address: ${hex.encode(signer.ethAddress)}`);
  console.log(`Signer.forCaller() public key: ${hex.encode(signer.publicKey)}`);

  signer.signWithEcsda(keccak256(CALLDATA)).then(signature => {
    console.log(`Signature r: ${hex.encode(signature.r)}`);
    console.log(`Signature s: ${hex.encode(signature.s)}`);
  })
}

/****************************************/
/********* MORE EXAMPLES BELOW **********/ 
/****************************************/

namespace examples {

  /**
   * In addition to Signer.forCaller(), you can also create a signer for the
   * Frosty Function itself. This signer is shared among all callers of the function,
   * so it is on the developer to perform proper access control.
   */
  function signerForFunction(): void {
    const signer = Signer.forFunction();
    console.log(`Signer.forFunction() ethereum address: ${hex.encode(signer.ethAddress)}`);
    console.log(`Signer.forFunction() public key: ${hex.encode(signer.publicKey)}`);

    let hash = keccak256(Uint8Array.wrap(String.UTF8.encode("Hello World!")));
    signer.signWithEcsda(hash).then(signature => {
      console.log(`Signature r: ${hex.encode(signature.r)}`);
      console.log(`Signature s: ${hex.encode(signature.s)}`);
    })
  }

  /**
   * You can also derive additional signers by passing a derivation path to
   * either Signer.forCaller() or Signer.forFunction(). By using CALLER as the
   * derivation path, you can derive a unique signer per caller that is not shared
   * with other Frosty Functions.
   */
  function derivedSigner(): void {
    const derivationPath = new ArrayBuffer(4);
    new DataView(derivationPath).setInt32(0, CALLING_CHAIN_ID as i32);

    const signer = Signer.forFunction(Uint8Array.wrap(derivationPath));
    console.log(`Derived signer ethereum address: ${hex.encode(signer.ethAddress)}`);
    console.log(`Derived signer public key: ${hex.encode(signer.publicKey)}`);
  }

  /**
   * verifiableRandomness() returns 32 random bytes generated by chain-key cryptography,
   * see https://internetcomputer.org/docs/building-apps/network-features/randomness
   * Here we take the first 2 bytes to generate a random number between 0 and 65535.
   */
  function random(): void {
    const random: Promise<u16> = verifiableRandomness()
      .map<u16>(bytes => Uint16Array.wrap(bytes)[0])
      .then(rand => console.log(`Random number generated: ${rand}`));
  }

  /**
   * Example demonstrating the use of Promises.
   */
  function promises(): void {
    let localValue: u16 = 42;
    verifiableRandomness()
      // Use .map to transform the Promise value. As AssemblyScript is
      // strictly typed, the return value type needs to be specified.
      .map<u16>(bytes => Uint16Array.wrap(bytes)[0])
      // AssemblyScript currently does not support closures, but you
      // can use .mapWith to pass additional context to the callback.
      // Note: Closure support will be added with https://github.com/AssemblyScript/assemblyscript/pull/2964
      .mapWith<u16, u16>(localValue, (localValue, random) => random + localValue)
      // Use .then if you don't need to transform the value anymore.
      .then(result => console.log(`Random number plus local value: ${result}`));
  }
}
