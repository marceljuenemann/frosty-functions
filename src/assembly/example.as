import { CALLDATA, JOB_ID } from "frosty";
import { CALLING_CHAIN_NAME, CALLING_CHAIN_ID, EthWallet } from "frosty/evm";
import { verifiableRandomness } from "frosty/random";
import { Promise } from "frosty/promise";
import { hex } from "frosty/util";

function fib(n: u32): u32 {
  let a: u32 = 1;
  let b: u32 = 1;
  for (let i: u32 = 3; i <= n; i++) {
    const c: u32 = a + b;
    a = b;
    b = c;
  }
  return b;
}

export function main(): void {
  console.log(`Invoked from ${CALLING_CHAIN_NAME} (Chain ID: ${CALLING_CHAIN_ID})`);
  console.log(`Calldata is: ${hex.encode(CALLDATA)}`);
  console.log(`Job ID is: ${JOB_ID}`);


  for (let i: u32 = 1; i < 10; i++) {
    console.log(`fib(${i}) = ${fib(i)}`);
  }


  // Frosty automatically creates an Ethereum Wallet for the caller that invoked the
  // function. The private key is split across the nodes of the Internet Computer and
  // signs messages using Threshold ECDSA. Note that any Frosty Function can manage the
  // the `forCaller()` wallet as long as that caller agreed to invoke the function.
  const wallet = EthWallet.forCaller();
//  console.log(`Caller address: ${CALLER_ADDRESS}`);
  console.log(`Caller Frosty Wallet address: ${wallet.address()}`);

  // You can use wallet.signMessage to sign arbitrary EIP-191 messages.
  wallet.signMessage(String.UTF8.encode("Hello, World!")).then((signature) => {
    console.log(`Signature: ${hex.encode(signature)}`);
  });

  // You can transfer gas that you sent to the Frosty function into the wallet.
  // However, make sure to leave enough gas for the function execution to complete!
  // Note that this actually results in an Ethereum transaction with the usual gas
  // costs, which will be deducted from your gas account. Alternatively, you can also
  // send funds directly to wallet.address() outside of Frosty.
  wallet.depositGas(10000).then((txHash) => {
    console.log(`Transferred gas into Wallet.forCaller(). Tx hash: ${hex.encode(txHash)}`);
  });

  // verifiableRandomness() returns 32 random bytes generated by chain-key cryptography,
  // see https://internetcomputer.org/docs/building-apps/network-features/randomness
  // Here we take the first 2 bytes to generate a random number between 0 and 65535.
  const random: Promise<u16> = verifiableRandomness()
    .map<u16>(bytes => Uint16Array.wrap(bytes)[0])
    .then(rand => console.log(`Random number generated: ${rand}`));


  /**
  // TODO: Check for minimum amount
  // TODO: Generate a random number
  // TODO: Convert the random amount to WETH
  */

}


/****************************************/
/********* MORE EXAMPLES BELOW **********/ 
/****************************************/

namespace examples {

  /**
   * verifiableRandomness returns an ArrayBufferPromise that can be
   * converted to various typed arrays.
   */
  function randomness(): void {

  }
}
